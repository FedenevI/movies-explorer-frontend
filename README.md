# Макет dark-3
## https://www.figma.com/file/6FMWkB94wE7KTkcCgUXtnC/light-1?type=design&node-id=891-3857&mode=design&t=2o1n0jVrlmCiWxAF-0
# diplom
Критерии диплома:
JavaScript
Критерии, влияющие на работоспособность
 Функциональность проекта из брифа реализована полностью:
Общее
Все ссылки и кнопки в проекте работают.
Правильно работают оба состояния шапки: если пользователь не залогинился, в шапке должны быть кнопки «Войти» и «Регистрация», если пользователь залогинился, кнопки исчезают — и появляются кнопки «Фильмы», «Сохранённые фильмы» и «Аккаунт», в том числе и на главной странице.
При поиске текст запроса, найденные фильмы и состояние переключателя короткометражек сохраняются в хранилище. Если пользователь повторно переходит на страницу фильмов, то при монтировании компонента данные достаются из локального хранилища. Страница отображается в соответствии с загруженными из хранилища данными.
Комментарий: В вашем задании указано: при каждом поиске на странице фильмов результаты поиска фильмов нужно сохранять в localstorage. В сохраняемые данные должны входить и строка поиска и статус чекбокса «Короткометражки», чтобы пользователю при повторном переходе на страницу фильмов, можно было вывести на экран информацию, полностью совпадающую с его последним поиском (с расстановкой актуального состояния лайков) перед уходом на другую страницу или перезагрузкой страницы. Эту информацию можно будет доставать из хранилища при монтировании и перерисовке компоненты фильмов. При логауте пользователя нужно эту информацию в хранилище и стейте (useState, если она там есть) уничтожать.
**Комментарий: Сейчас результат поиска и положение чекбокса не восстанавливаются из хранилища при переходе на Фильмы с других страниц. **
Комментарий: Сохранять данные последнего поиска на странице «Сохранённые фильмы» для их показа при повторном входе на эту страницу не нужно. https://skr.sh/sODfNKOPF4C Нужно, чтобы при входе на страницу «Сохранённые фильмы» пользователь видел все свои сохранённые карточки без задания параметров поиска.
Все формы валидируются и на стороне клиента. Пользователь не может отправить запрос с невалидными данными.
Комментарий: не работает валидация формы поиска, по заданию "После сабмита формы поиска производится валидация. Если в поле не введён текст, выводится ошибка «Нужно ввести ключевое слово». Обратите внимание, что в строке поиска не нужна "живая" валидация, валидация происходит ТОЛЬКО после сабмита."
Страницы «Регистрация» и «Авторизация»:
На странице «Регистрация» клик по кнопке «Зарегистрироваться» отправляет запрос на роут /signup, если данные введены корректно. Если запрос прошёл успешно, то автоматически производится вход и редирект на страницу /movies.
На странице «Авторизация» клик по кнопке «Войти» отправляет запрос на роут /signin, если данные введены корректно. Если запрос прошёл успешно, происходит редирект на страницу /movies.
Все формы валидируются и на стороне клиента.
Комментарий: https://disk.yandex.ru/d/p5rP4ovi7wwbEw Несуществующее в условиях задания ограничение
Комментарий: https://disk.yandex.ru/d/_EP82POvCzoCeQ Валидация поля не отвечает условиям брифа
Страница редактирование профиля:
На странице редактирования профиля клик по кнопке «Сохранить» отправляет запрос на роут /users/me, если данные введены корректно.
Комментарий: https://disk.yandex.ru/d/MqD7wNtbWV9GRA При изменении имени пользователя невозможно сохранить изменения, кнопка сохранения недоступна
Пользователю отображается уведомление об успешном запросе к серверу при сохранении профиля.
Комментарий: При сохранении профиля пользователь должен увидеть сообщение о подтверждении, вид сообщения может быть любым на ваш выбор
Если на странице редактирования профиля введённая информация соответствует текущим данным пользователя, кнопка «Сохранить» заблокирована и нельзя отправить запрос сохранения.
Поиск фильмов:
Прелоадер крутится во время выполнения запроса фильмов.
Работа с фильтром настроена:
Поиск фильмов регистронезависимый.
Если запрос выполняется впервые, то работа с фильтром происходит после получения данных.
Комментарий: https://skr.sh/sODzxNH3u7X По условию задания запрос к базе с фильмами должен производиться при первом поиске, а не при монтировании компонента или загрузке страницы
Если карточки уже были отображены на странице в блоке результатов, клик по чекбоксу «Короткометражки» приводит к повторной фильтрации результата.
После успешного сабмита формы поиска появляется блок с результатами.
Если ничего не найдено, выводится надпись «Ничего не найдено».
На странице всех фильмов в блоке результата отображается такое же количество карточек, как в макете. Нажатие на кнопку «Ещё» отображает следующий ряд с тем же числом карточек. При отображении всех карточек кнопка «Ещё» скрывается.
Комментарий: https://skr.sh/sODR2qXE6cI по заданию количество карточек должно зависеть от размера экрана и вашего макета. Сейчас добавляемое количество карточек при нажатии "Еще" в мобильном варианте не соответствует требованию задания.
Комментарий: https://skr.sh/sODR2qXE6cI Необходимо ориентироваться на фактическое изменение количества карточек в строке. Если карточки уже выдаются по две в ряду, значит при любом поиске должно быть выдано 8 и кнопка "Еще" должна добавлять 2. Проверьте все точки переходов и соответствие выдаваемых результатов условию задания. Например, на разрешении 1088px фильмы выводятся по 2 в ряду, однако кнопка "Еще" добавляет по 3. А на разрешении 742px добавляется по одному фильму, хотя в блоке результата фильмы все так-же по два в ряду.
Комментарий: При выполнении поиска в блок результата необходимо выдавать то количество карточек, которое соответствует условию задания для текущего разрешения экрана. Сейчас выдается то количество, которое уже было выдано до поиска. Например, при размещении карточек в одну колонку поиск должен выдавать 5 карточек. Если нажать кнопку "Еще", то добавится 1 и в блоке результата будет уже 6. Теперь при выполнении нового поиска в блок результата нужно вывести снова 5 карточек, но сейчас будет выведено 6, как и было до поиска.
Комментарий: На странице "Сохраненные фильмы" не предусмотрена кнопка "Еще", необходимо всегда выводить все фильмы пользователя по условию, без ограничения количества. Все условия по количеству фильмов относятся только к странице "Фильмы".
Карточки:
Карточка состоит из изображения, названия фильма и его длительности. Длительность фильма рассчитывается корректно и соответствует формату в макете. Клик по карточке ведёт на трейлер фильма.
Кнопка лайка имеет правильное состояние, в зависимости от того, добавлен ли фильм в сохранённые или нет.
При клике на иконку «Лайк» в блоке карточки выполняется запрос к /movies нашего API для установки или снятия лайка, в зависимости от текущего состояния.
На странице «Сохранённые фильмы»:
Отображается форма поиска. Она позволяет искать фильмы по уже полученным данным о сохранённых фильмах.
Комментарий: https://skr.sh/sL7lY5sIa3o Формы поиска на разных страницах не должны зависеть друг от друга. Сейчас положение чекбокса Короткометражка переносится с одной страницы на другую
Блок карточки содержит кнопку удаления, а не лайка.
Комментарий: В мобильной версии не существует наведения мыши и крестик удаления фильма не появится, пользователю не понятно, куда нужно нажать, чтобы удалить фильм. Хорошо, если в мобильной версии крестик будет виден, именно так определено в макете.
При нажатии на кнопку удаления выполняется запрос на удаление фильма. После успешного запроса карточка удаляется со страницы.
 Отсутствуют серьёзные баги, которые возникают при работе с сервисом, например:
Удалённые или добавленные карточки фильмов появляются только после перезагрузки страницы.
Если осталось отобразить меньше карточек фильмов, чем в полном ряду, то нажатие кнопки «Ещё» вызывает появление ошибок в консоли.
При удалении сохранённых карточек на соответствующей странице «Сохранённые фильмы» их по-прежнему можно найти через поиск. Поиск начинает корректно работать только после перезагрузки страницы.
Другие баги, которые возникают при работе с сервисом и требуют перезагрузки страницы или «ломают» пользовательский опыт.
Регистрация и авторизация:
 Роуты /saved-movies, /movies, /profile защищёны HOC-компонентом ProtectedRoute. Роуты / , /signin, /signup не являются защищёнными.
Комментарий: Компонент ProtectedRoute в проекте не реализован
 При попытке перейти на любой защищённый роут происходит редирект на / .
 Если пользователь был авторизован и закрыл вкладку, он может вернуться сразу на любую страницу приложения по URL-адресу, кроме страниц авторизации и регистрации.
 После успешного вызова обработчика onSignOut происходит редирект на /.
 Корректно используются хуки роутинга.
 При попытке перейти на несуществующую страницу происходит редирект на страницу «404». Кнопка «Назад» работает корректно.
 Корректно используются компоненты <Switch />, <Route /> и <Redirect />.
Работа с JWT выполнена корректно:
 JWT-токен хранится в localStorage или в cookie,
 Jwt проверяется запросом к серверу, а не только в локальном хранилище.
Комментарий: Если при любых запросах с проверкой Jwt, сервер приложения возвращает статус ошибки (токен может оказаться невалидным, даже будучи в наличии на клиенте, или может быть уничтожен в localstorage авторизованным пользователем "вручную"), пользователь должен становиться неавторизованным - должен происходить полный "логаут" пользователя на главную страницу с шапкой неавторизованного пользователя с удалением всей его информации из хранилища и стейтов. Сейчас в случае невалидного или уничтоженного токена в localstorage, после перезагрузки сайта, логаут не происходит, пользователь остается на странице с фильмами.
 При выходе из аккаунта jwt удаляется.
Хуки:
 Хуки не используются внутри условных блоков или циклов.
 Хуки вызываются в основной функции компонента.
 При использовании классовых компонентов эффекты описаны внутри методов жизненного цикла компонента.
 Имена пользовательских хуков начинаются с use.
Контекст:
 В корневом компоненте App создана стейт-переменная, которая хранит данные пользователя. Она используется в качестве значения для провайдера контекста.
 В компонент App внедрён контекст через CurrentUserContext.Provider.
 Компоненты, в которых используются данные профиля, подписаны на контекст.
Асинхронные запросы к API:
 Запросы можно осуществлять через Fetch API или XMLHttpRequest, сторонние библиотеки, такие как axios или jQuery, не применяются.
 Запросы к API вынесены в отдельные файлы: MainApi.js и MoviesApi.js.
 Первый обработчик then возвращает res.json. res проверяется на корректность.
 Цепочка обработки промисов завершается блоком catch.
 Не выполняются лишние запросы к бэкенду, например: запрос всех фильмов с сервиса beatfilm-movies производится только при первом поиске, все сохранённые фильмы не запрашиваются с сервера при каждом лайке или дизлайке, данные пользователя запрашиваются один раз при запуске приложения.
 Именование:
имена переменных, функций и параметров написаны в camelCase,
имена переменных — существительные,
имена переменных, функций и компонентов соответствуют содержимому,
имена коллекций NodeList — существительные во множественном числе,
имя функции начинается с глагола и отражает то, что она делает,
для именования запрещены: транслит и неуместные сокращения.
Хорошие практики
 Начальное состояние стейт-переменных содержит корректный тип данных.
 Для элементов списка используется уникальный ключ key, а не индекс массива.
 Запросы к API описаны внутри компонента App или в корневых компонентах страниц.
 Для внутренних ссылок в приложении используются компоненты из библиотеки react-router.
 Не происходит утечки памяти при навешивании обработчиков. Все обработчики, добавленные через addEventListener, удаляются при размонтировании компонента.
Обработка ошибок API:
 пользователь получает сообщение в случае любой ошибки,
 поля формы заблокированы во время отправки запросов и у пользователя нет возможности отправить новый запрос до завершения предыдущего.
Комментарий: на время выполнения запроса считается хорошей практикой блокировать поля ввода и кнопку отправки формы, что бы пользователь не мог выполнить новые запросы до завершения предыдущего
Комментарий: не нужно очищать поля формы до ответа сервера подтверждением, у пользователя должна быть возможность исправить данные, а не вводить их заново. На время выполнения запросанужно только блокировать поля ввода и кнопку отправки формы, что бы пользователь не мог выполнить новые запросы до завершения предыдущего
 Фиксированные значения (константы) именуются заглавными буквами и вынесены в отдельный конфиг-файл.
Комментарий: длительность короткометражек, количество фильмов, отображаемое при поиске или добавляемое при нажатии кнопки "Еще" на разных размерах экрана и точки перестроения экрана нужно вынести в константы
Рекомендации
 Сторонние JavaScript-библиотеки не применяются.
Комментарий: Используются сторонние библиотеки.
 Используются семантически правильные блоки для компонентов. Не используются div или иные лишние HTML-тэги для компонентов, которые состоят из одноуровневых блоков.
Комментарий: есть лишние обертки вокруг одноуровневых блоков
 Отсутствует «мусор» в коде:
нет беспорядка в коде,
нет лишнего кода: переменная объявлена, но не используется или есть какая-то лишняя логика,
код форматирован одинаково, соблюдается иерархия отступов.

## pull request
### https://github.com/FedenevI/movies-explorer-frontend/pull/2

